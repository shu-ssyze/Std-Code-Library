

# 图论

## 最小生成树

### Prim

```c++
#include <bits/stdc++.h>
const int maxn = 200;
const int inf = 0x3f3f3f3f;
using namespace std;
int N,dis[maxn][maxn],vis[maxn],ans,mndis[maxn];
void prim(){
    //初始化，将1号点加入到生成树中
    ans = 0;
    int cnt = 1;
    vis[1] = 1;
    for(int i = 1;i <= N;++i) mndis[i]=dis[1][i];
    while(cnt != N){
        int mn = inf,id;
        //找出所有点中距离生成树最近的点
        for(int i = 1; i <= N; i++){
            if(!vis[i] && mndis[i] < mn){
                mn = mndis[i];
                id = i;
            }
        }
        //将找到的点加入生成树
        vis[id] = 1;
        ans += mn;
        cnt++;
        //更新剩余点到树的距离
        for(int i = 1; i <= N; i++) mndis[i] = min(mndis[i],dis[id][i]);

    }
}
```

### Kruskal

```c++
#include <bits/stdc++.h>
const int maxn = 200;
using namespace std;
struct edge{
    int from;
    int to;
    int val;
    edge(int a = 0,int b = 0,int c = 0){from=a;to=b;val=c;}
    friend bool operator > (edge a,edge b){
        return a.val > b.val;
    }
};
int N,M,father[maxn];
priority_queue< edge,vector<edge>,greater<edge> > Q;
int Find(int a){
    if(father[a]==a) return a;
    return father[a]=Find(father[a]);
}
void Union(int a,int b){
    int f1=Find(a),f2=Find(b);
    father[f2] = f1;
}
void init(){
    for(int i = 1; i <= M; ++i) father[i]=i;
    while(!Q.empty()) Q.pop();
}
void kruscal(){
    int ans = 0,cnt = 0;
    while(!Q.empty() && cnt != M-1){
        edge temp = Q.top();
        Q.pop();
        int f = temp.from,t = temp.to,v = temp.val;
        if(Find(t)!=Find(f)){
            Union(f,t);
            cnt++;
            ans+=v;
        }
    }
    //cnt小于M-1则没有连通，否则ans为最小生成树大小
    if(cnt != M-1) puts("?");
    else printf("%d\n",ans);
}
```

## 最短路

### dijkstra(单源最短路)

```c++
#include <iostream>
#include <queue>
#include <cstring>
#include <algorithm>
const int maxn = 1000+50;
const int inf = 0x3f3f3f3f;
using namespace std;
struct edge{
    int to;
    int val;
    edge(int a = 0,int b = 0){to=a;val=b;}
};
struct nod{
    int pos;
    int d;
    nod(int a = 0,int b = 0){pos=a;d=b;}
    //优先队列重载大于符号
    friend bool operator > (nod a, nod b){
        return a.d>b.d;
    }
};
//邻接表
vector<edge> E[maxn];

int T,N,dis[maxn];//dis[i]为从X到i的最短距离，可以根据情况扩充为d[i][j][k].....

//加边，无向图时添加两条边
void add(int f,int t,int v){
    E[f].push_back(edge(t,v));
    E[t].push_back(edge(f,v));
    return;
}

void dij(){
    memset(dis,inf,sizeof(dis));
    priority_queue< nod,vector<nod>,greater<nod> > Q;
    dis[N]=0;
    Q.push(nod(N,0));//初始态,N为出发点
    while(!Q.empty()){
        nod temp = Q.top();
        int pos = temp.pos;
        int d = temp.d;
        Q.pop();
        if(d > dis[pos]) continue;
        //遍历邻接表更新相邻点的最短距离
        for(int i = 0; i < E[pos].size(); ++i){
            int to = E[pos][i].to;
            int val = E[pos][i].val;
            int nd = d + val;
            if(nd < dis[to]){
                dis[to] = nd;
                Q.push(nod(to,nd));
            }
        }
    }
}
```

### SPFA(单源最短路)

可以判负环

```c++
const int maxn = 1e5 + 5;
const int INF = 0x3f3f3f3f;
struct edge
{
    int to;
    int val;
    edge(int a = 0, int b = 0)
    {
        to = a; val = b;
    }
};
vector<edge> mp[maxn];  //邻接表存图
int d[maxn];            //最短距离
bool vis[maxn];         //记录节点是否在队列里
int EnqueNum[maxn];     //记录进队次数
int PointNum;           //节点数
bool spfa(int s)        //s为起点
{
    memset(d,INF,sizeof(d));
    d[s] = 0;
    queue<int> que;     //记录路径改变的点
    que.push(s);
    vis[s] = true;
    EnqueNum[s]++;
    while(!que.empty())
    {
        int temp = que.front();
        que.pop();
        vis[temp] = false;
        for(int i = 0; i < mp[temp].size(); i++)
        {
            edge e = mp[temp][i];
            //如果可以松弛
            if(d[e.to] > d[temp] + e.val)
            {
                d[e.to] = d[temp] + e.val;
                //且该点不在队列里
                if(!vis[e.to])
                {
                    vis[e.to] = true;
                    que.push(e.to);
                    EnqueNum[e.to]++;
                    if(EnqueNum[e.to] >= PointNum)	//判负环
                        return false;
                }
            }
        }
    }
    return true;
}
```

### floyd(多源最短路)

```c++
//注意k,i,j！！！
for(int k=1;k<=n;k++)
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
```

## 匈牙利算法(最大匹配)

最小点覆盖 = 最大匹配，最大独立集 = 点 - 最小点覆盖

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5;

char mp[55][55];
int R,C,ans,lnum,rnum,match[maxn],a[55][55],b[55][55];
bool vis[maxn];
vector<int> E[maxn];

bool dfs(int u){
    for(int i = 0; i < E[u].size(); ++i){
        int v = E[u][i];
        if(!vis[v]){
            vis[v]=1;
            if(match[v]==-1 || dfs(match[v])){
                match[v]=u;
                return 1;
            }
        }
    }
    return 0;
}

int xyl(){
    memset(match,-1,sizeof(match));
    ans = 0;
    for(int i = 0; i < lnum; ++i){
        memset(vis,0,sizeof(vis));
        ans += dfs(i);
    }
    return ans;
}

```

## Hopcroft_Carp

```c++
struct Hopcroft_Carp{
    vector<int> G[maxn];
    int Mx[maxn],My[maxn],Nx,Ny;
    int dx[maxn],dy[maxn],dis;
    bool vis[maxn];

    void add(int u,int v){
        G[u].push_back(v);
    }
    bool searchP()
    {
        queue<int> q;
        dis=inf;
        memset(dx,-1,sizeof(dx));
        memset(dy,-1,sizeof(dy));
        for(int i=1;i<=Nx;i++){
            if(Mx[i]==-1){
                q.push(i);
                dx[i]=0;
            }
        }
        while(!q.empty()){
            int u=q.front();
            q.pop();
            if(dx[u]>dis) break;
            for(int i=0;i<G[u].size();i++){
                int v=G[u][i];
                if(dy[v]==-1){
                    dy[v]=dx[u]+1;
                    if(My[v]==-1) dis=dy[v];
                    else{
                        dx[My[v]]=dy[v]+1;
                        q.push(My[v]);
                    }
                }
            }
        }
        return dis!=inf;
    }

    bool dfs(int u)
    {
        for(int i=0;i<G[u].size();i++){
            int v=G[u][i];
            if(!vis[v]&&dy[v]==dx[u]+1){
                vis[v]=1;
                if(My[v]!=-1&&dy[v]==dis) continue;
                if(My[v]==-1||dfs(My[v])){
                    My[v]=u;
                    Mx[u]=v;
                    return true;
                }
            }
        }
        return false;
    }

    int run()
    {
        int res=0;
        memset(Mx,-1,sizeof(Mx));
        memset(My,-1,sizeof(My));
        while(searchP()){
            memset(vis,0,sizeof(vis));
            for(int i=1;i<=Nx;i++){
                if(Mx[i]==-1&&dfs(i)) res++;
            }
        }
        
        return res;
    }

    void init(int _NX,int _NY){
        for(int i = 1; i <= Nx; ++i) G[i].clear();
        Nx = _NX,Ny = _NY; 
    }
}HC;
```

## KM算法(带权最大匹配)

三份板子 不知道哪份是正确实现

```c++
//不确定对不对的O(n^3)
const int AX = 3e2+6;
bool visx[AX];
bool visy[AX];
int w[AX][AX];
int lx[AX] , ly[AX];  //可行性顶标
int linker[AX];  //记录匹配的边
int slack[AX];   //记录每个j相连的i的最小的lx[i]+ly[j]-w[i][j]
int n ;
bool dfs( int x ){
    visx[x] = true;
    for( int y = 1 ; y <= n ; y ++ ){
        if( !visy[y] && lx[x] + ly[y] == w[x][y] ){
            visy[y] = true;
            if( linker[y] == -1 || dfs( linker[y] ) ){
                linker[y] = x ;
                return true;
            }
        }else if( slack[y] > lx[x] + ly[y] - w[x][y] ){//x,y不在相等子图且y不在增广路
            slack[y] = lx[x] + ly[y] - w[x][y];
        }
    }
    return false;
}

void KM(){
    memset( linker , -1 , sizeof(linker) );
    memset( ly , 0 , sizeof(ly) );
    for( int i = 1 ; i <= n ; i++ ){
        lx[i] = -INF;
        for( int j = 1 ; j <= n ; j++ ){
            if( lx[i] < w[i][j] ) lx[i] = w[i][j];
        }
    }
    for( int x = 1 ; x <= n ; x++ ){
        for( int i = 1 ; i <= n ; i++ ) slack[i] = INF;//每次匹配x都要更新slack
        while(1){
            memset( visx , false , sizeof(visx) );
            memset( visy , false , sizeof(visy) );
            if( dfs(x) ){
                break;
            }else{ // 匹配失败后x一定在增广路，寻找不在增广路的j
                int delta = INF;
                for( int j = 1 ; j <= n ; j++ ){
                    if( !visy[j] && delta > slack[j] ){
                        delta = slack[j];
                    }
                }

                for( int i = 1 ; i <= n ; i++ ){
                    if( visx[i] ) lx[i] -= delta;
                }
                for( int i = 1 ; i <= n ; i++ ){
                    if( visy[i] ) ly[i] += delta;
                    else slack[i] -= delta;
                    //修改顶标后，要把所有的slack值都减去delta
                     //slack[j] = min(lx[i] + ly[j] -w[i][j])
                     //在增广路的lx[i]减少，所以不在增广路的slack[j]减小
                }
            }
        }
    }
}
```



```c++
void bfs(int k)
{
    int px,py=0,yy=0,d;
    memset(pre,0,sizeof pre);
    memset(slack,0x3f,sizeof slack);
    linky[py]=k;

    do
    {
        px=linky[py],d=0x3f3f3f3f,vis[py]=1;
        for(int i=1;i<=n;i++)
            if(vis[i]==0)
            {
                if(slack[i]>dbx[px]+dby[i]-C[px][i])
                    slack[i]=dbx[px]+dby[i]-C[px][i],pre[i]=py;
                if(slack[i]<d) d=slack[i],yy=i;
            }
        for(int i=0;i<=n;i++)
            if(vis[i]) dbx[linky[i]]-=d,dby[i]+=d;
            else slack[i]-=d;
        py=yy;
    }while(linky[py]!=0);
    while(py) linky[py]=linky[pre[py]],py=pre[py];
}
void km()
{
    memset(dbx,0,sizeof dbx);
    memset(dby,0,sizeof dby);
    memset(linky,0,sizeof linky);
    for(int i=1;i<=n;i++)
        memset(vis,0,sizeof vis),bfs(i);
}
```



```c++
const int maxn = 300;
const int inf = 0x3f3f3f3f;

int n;
bool vis_l[maxn],vis_r[maxn];
int match[maxn],slack[maxn],ex_l[maxn],ex_r[maxn];
int E[maxn][maxn];


bool dfs(int u){
    vis_l[u]=1;
    for(int v = 0; v < n; ++v){
        int w = E[u][v];
        if(!vis_r[v] && ex_l[u]+ex_r[v]==w){
            vis_r[v]=1;
            if(match[v]==-1||dfs(match[v])){
                match[v]=u;
                return 1;
            }
        }
        else slack[v] = min(slack[v],ex_l[u]+ex_r[v]-w);
    }
    return 0;
}

int km(){
    memset(match,-1,sizeof(match));
    memset(ex_r,0,sizeof(ex_r));
    for(int i = 0; i < n; ++i){
        ex_l[i] = -inf;
        for(int j = 0; j < n; ++j)
            ex_l[i]=max(ex_l[i],E[i][j]);
    }
    for(int i = 0; i < n; ++i){
        memset(slack,inf,sizeof(slack));
        while(true){
            memset(vis_l,0,sizeof(vis_l));
            memset(vis_r,0,sizeof(vis_r));
            if(dfs(i)) break;
            else{
                int d = inf;
                for(int j = 0; j < n; ++j)
                    if(!vis_r[j]) d = min(d,slack[j]);
                for(int j = 0; j < n; ++j){
                    if(vis_l[j]) ex_l[j]-=d;
                    if(vis_r[j]) ex_r[j]+=d;
                    else slack[j] -= d;
                }
            }
        }
    }
    int res = 0;
    for(int i = 0; i < n; ++i)
        if(match[i] > -1)
            res += E[match[i]][i];
    return res;
}
```

## 网络流

### Dinic
数组实现
```c++
const int inf = 0x3f3f3f3f;
 
struct Dinic{
    struct edge{
        int to,f,nxt;
    };
    int n,m,S,T,tot;
    edge e[10*maxn];
    int head[maxn],cur[maxn],dep[maxn];

    void add( int u, int v, int f )
    {
        e[tot].to = v;
        e[tot].f = f;
        e[tot].nxt = head[u];
        head[u] = tot++;
        e[tot].to = u;
        e[tot].f = 0;
        e[tot].nxt = head[v];
        head[v] = tot++;
    }

    int bfs(int node)
    {
        memset(dep,0,sizeof(dep));
        memcpy(cur,head,sizeof(cur));
        dep[node] = 1;
        queue <int> Q;
        Q.push(node);
        while ( !Q.empty() ) {
            int x = Q.front();Q.pop();
            for ( int i=head[x]; i!=-1; i=e[i].nxt ) {
                int y = e[i].to,f = e[i].f;
                if ( !dep[y] && f ) {
                    dep[y] = dep[x] + 1;
                    Q.push(y);
                }
            }
        }
        return dep[T];
    }

    int dfs( int x, int flow ) // dfs找增广路
    {
        if ( x==T ) {
            return flow;
        }
        int sum = 0;
        for ( int i=cur[x]; i!=-1; i=e[i].nxt ) {
            cur[x] = i;
            int y = e[i].to, f = e[i].f;
            if ( f && dep[y]==dep[x]+1 ) {
                int t = dfs(y,min(flow-sum,f)); // 优化1
                sum += t;
                e[i].f -= t;
                e[i^1].f += t;
                if ( sum==flow ) break; // 优化1
            }
        }
        if ( sum==0 ) { // 如果sum==0，那么这个点之前没有增广路，深度清零
            dep[x] = 0;
        }
        return sum;
    }

    int run(){
        int ans = 0;
        while(bfs(S)){
            ans += dfs(S,inf);
        }
        return ans;
    }

    //边数尽量给多以防RE
    void init(int _n,int _m,int _S,int _T)
    {
        n = _n,m = _m,S = _S,T = _T,tot = 0;
        memset(head,-1,sizeof(head));
        memset(cur,0,sizeof(cur));
        memset(dep,0,sizeof(dep));
    }
}din;
```

vector实现
```c++
struct Dinic{
    struct edge{
        int to,f,nxt;
    };
    int n,m,S,T,tot;
    vector<edge> e;
    vector<int> head,cur,dep;
 
    void add( int u, int v, int f )
    {
        e[tot].to = v;
        e[tot].f = f;
        e[tot].nxt = head[u];
        head[u] = tot++;
        e[tot].to = u;
        e[tot].f = 0;
        e[tot].nxt = head[v];
        head[v] = tot++;
    }
 
    int bfs(int node)
    {
        for(int i = 1; i <= n; ++i) dep[i] = 0,cur[i] = head[i];
        dep[node] = 1;
        queue <int> Q;
        Q.push(node);
        while ( !Q.empty() ) {
            int x = Q.front();Q.pop();
            for ( int i=head[x]; i!=-1; i=e[i].nxt ) {
                int y = e[i].to,f = e[i].f;
                if ( !dep[y] && f ) {
                    dep[y] = dep[x] + 1;
                    Q.push(y);
                }
            }
        }
        return dep[T];
    }
 
    int dfs( int x, int flow ) // dfs找增广路
    {
        if ( x==T ) {
            return flow;
        }
        int sum = 0;
        for ( int i=cur[x]; i!=-1; i=e[i].nxt ) {
            cur[x] = i;
            int y = e[i].to, f = e[i].f;
            if ( f && dep[y]==dep[x]+1 ) {
                int t = dfs(y,min(flow-sum,f)); // 优化1
                sum += t;
                e[i].f -= t;
                e[i^1].f += t;
                if ( sum==flow ) break; // 优化1
            }
        }
        if ( sum==0 ) { // 如果sum==0，那么这个点之前没有增广路，深度清零
            dep[x] = 0;
        }
        return sum;
    }
 
    int run(){
        int ans = 0;
        while(bfs(S)){
            ans += dfs(S,inf);
        }
        return ans;
    }
 
    //边数尽量给多以防RE
    void init(int _n,int _m,int _S,int _T)
    {
        n = _n,m = _m,S = _S,T = _T,tot = 0;
        e.resize(m+100);
        head.assign(n+100,-1);
        cur.assign(n+100,0);
        dep.assign(n+100,0);
    }
}din;
```

### 费用流

```c++
const int maxn = 1e3 + 7;
const int INF = 0x3f3f3f3f;
struct Edge
{
    int from, to, cap, flow, cost;
};
struct MCMF
{
    int n, m, s, t;
    vector<Edge> edges;
    vector<int> G[maxn];
    int inq[maxn];
    int d[maxn]; //最短路数组
    int p[maxn]; //记录路径
    int a[maxn]; //记录流量
    void init(int n)
    {
        this->n = n;
        for (int i = 0; i < n; i++)
            G[i].clear();
        edges.clear();
    }
    void addedge(int from, int to, int cap, int cost)
    {
        edges.push_back(Edge{from, to, cap, 0, cost});
        edges.push_back(Edge{to, from, 0, 0, -cost});
        m = edges.size();
        G[from].push_back(m - 2);
        G[to].push_back(m - 1);
    }
    bool spfa(int s, int t, int &flow, int &cost)
    {
        for (int i = 0; i < n; i++)
            d[i] = INF;
        memset(inq, 0, sizeof(inq));
        d[s] = 0;
        inq[s] = 1;
        p[s] = 0;
        a[s] = INF;
        queue<int> q;
        q.push(s);
        while (!q.empty())
        {
            int u = q.front();
            q.pop();
            inq[u] = 0;
            for (int i = 0; i < G[u].size(); i++)
            {
                Edge &e = edges[G[u][i]];
                if (e.cap > e.flow && d[e.to] > d[u] + e.cost)
                {
                    d[e.to] = d[u] + e.cost;             //松弛
                    p[e.to] = G[u][i];                   //记录上一个点
                    a[e.to] = min(a[u], e.cap - e.flow); //流量控制
                    if (!inq[e.to])
                    {
                        q.push(e.to);
                        inq[e.to] = 1;
                    }
                }
            }
        }
        if (d[t] == INF)
            return false; //不存在最短路
        flow += a[t];
        cost += d[t] * a[t];
        int u = t;
        while (u != s)
        {
            edges[p[u]].flow += a[t];
            edges[p[u] ^ 1].flow -= a[t];
            u = edges[p[u]].from;
        }
        return true;
    }
    int Mincost(int s, int t)
    {
        int flow = 0, cost = 0;
        while (spfa(s, t, flow, cost))
            ;
        return cost;
    }
};
```

### 树链剖分

```c++
const int maxn = 1e5+200;
int n,weight[maxn],Size[maxn],sum[maxn];
int dep[maxn],cnt;
vector<int> E[maxn];
int parent[maxn],son[maxn],top[maxn],rk[maxn];

void dfs1(int u,int fa,int root){
    parent[u]=fa;dep[u]=dep[fa]+1;Size[u]=1;
    for(int v,i = 0; i < E[u].size(); ++i){
        if((v=E[u][i])!=fa){
            dfs1(v,u,root);Size[u]+=Size[v];
            if(Size[v]>Size[son[u]]) son[u]=v;
        }
    }

}

int dfs2(int u,int t){
    top[u] = t;
    rk[u] = ++cnt;
    sum[rk[u]] = weight[u];
    if(son[u]!=0) dfs2(son[u],t);
    for(int v,i = 0; i < E[u].size(); ++i)
        if((v=E[u][i])!=son[u]&&v!=parent[u]) dfs2(v,v);
}

int Treequery(int a,int b){
    int res = 0;
    while(top[a]!=top[b]){
        if(dep[top[a]]<dep[top[b]]) swap(a,b);
        res += sum[rk[a]]-sum[rk[top[a]]-1];
        a = parent[top[a]];
    }
    if(dep[a]<dep[b]) swap(a,b);
    res += sum[rk[a]]-sum[rk[b]-1];
    return res;
}
```

